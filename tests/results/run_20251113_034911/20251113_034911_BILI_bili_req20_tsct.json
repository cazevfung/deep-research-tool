{
  "success": true,
  "bv_id": "BV1UMVKzEESL",
  "url": "https://www.bilibili.com/video/BV1UMVKzEESL/",
  "content": "AI agent是一个小程序，它负责在用户AI模型和功能函数之间进行传话。比如说我们想让AI帮忙管理本地文件，但模型本身是没办法直接读取硬盘的。所以我们需要写好一系列的文件管理函数，再把这些函数注册到agent里面，agent就会把这些函数的信息通过system prompt或者function col的方式告诉AI模型，于是模型就可以返回指令，引导agent调用相应的函数去完成用户的请求了。如果你还想了解更多关于agent prompt方生col甚至mcp的内容，可以看这期视频的完整讲解，十分钟带你理清他们之间的关系。现在我们回到代码，今天我们要开发的是一个简单的AI agent，他负责管理test文件夹下的这些A B C D文件。这些文件都是一些事例代码，有的是用Python写的，有的是用C语言写的，还有的用的是go为了让AI模型能看得见这些文件，我们需要提供几个本地函数。我已经预先写好了三个函数，read file负责读文件，list files负责列目录，还有rename file负责改文件名。他们都是很普通的文件操作的代码，和AI没有直接关系，这里我就不展开了。但是有几点需要注意，首先是函数名以及参数名一定要写的清晰，最好一看就知道是干什么的，然后返回值和参数类型也要加上明确的类型标注，因为AI模型就是通过这些信息了解函数功能的。但是如果函数比较复杂，光靠名字说不清楚的时候怎么办呢？这个时候我们可以写dostring，dostring的内容也会被AI模型看到，比如说我可以用read field dostring告诉AI，如果文件不存在函数就会返回错误提示。总之我们就把AI当成一个程序员，我们的任务就是给他提供api和api的文档。因为这里的函数都非常的简单，剩下的dostring我就不写了，接下来我们开始写agent。今天我们要用到的库是排单，AI模型，用的是Google的jmin但是单AI，几乎支持所有的模型，你可以参考官方文档选择不同的接口连接，我会放在视频简介中。首先我们先创建一个代表模型的gnine model实例。模型的api我不建议直接写在代码里面，因为太不安全了。一般情况下我们可以放到环境变量里面。比如对于min模型来讲，我们就要把key放到一个叫做minapi的变量里面。但是如果我们每次都要手动更改环境变量也挺麻烦的。所以更常见的做法是把它写到一个叫做点一V的文件里面。然后我们可以用Python dot in的load函数进行加载。它的作用和我们直接把key写到环境变量中是一样的，不过注意提交代码的时候不要把贬V文件也一起提交到g上, 这样我们的模型就准备好了。接下来我们生成一个agent对象，负责和模型用户函数进行通信。我们刚刚创建的模型module是agent的第一个参数。除了模型本身，我们还需要传入一个system prompt来定义AI的角色信息。比如说这里我设定它是一个经验丰富的程序员。最后我们通过two参数，把刚刚展示过的read file这些工具函数注册在agent中。写到这里，我们的模型agent和工具函数就都已经准备好了。接下来我们来写主程序，这里我们直接通过标准输入来接受用户的指令。然后我们把用户的输入通过run think函数直接传给agent。这样agent它就会自动根据用户的需求和AI的返回结果来调用函数，并且完成用户的指令了。最后我们把AI的最终返回结果也打印出来。这样我们的程序基本上就写完了，我们来测试一下。比如说我让它列出abc D F这些文件使用的语言，我们就可以这样写。可以看到AI模型决定先调用list file，把所有的文件都列出来，然后一个一个的调用read file去读取他们的内容。最后根据内容再告诉我们每个文件大概是用什么语言写的。但是这里有一个问题，比如说我接着问他B文件的功能是什么？可以看到，A模型虽然也回答了出来，但是他又去读了一次B文件，但是他明明在刚才的那次对话之中已经读过B文件了，怎么还要重新再读一遍呢？这个是因为当我们每次调用agent run think函数的时候，默认它们之间是相互独立的。Agent是不会自动记住你上一次说过什么的，也不知道他刚刚读过哪些文件。所以如果我们想让agent记住上下文，我们还得自己保留一下聊天记录。其实也非常简单，因为在每次调用完agent run think函数之后，我们都能拿到一份完整的对话记录。这里我们就把它拷贝一份。然后下次发送消息的时候，我们把这段历史记录通过message history参数传递进去。由于有了上下文，AI就可以记住我们之前都说了什么。之前读过的文件B也就不需要再重新读一遍了，我们再来测试一下程序。我们还是先让它识别每个文件使用的语言。好，这一次我们让他根据文件的内容来给文件进行改名，我们可以这样写。可以看到这一次AI就没有再次读取文件的内容，而是直接调用了rename函数，给每个文件都加上了他们自己的扩展名。我们再去看一下test目录，可以看到文件名也都被正确的改了过来。这就是一个最基础的AI agent架构了，逻辑并不复杂，但背后的机制却很有意思。希望这个视频能帮你更清楚的理解整个流程。这里是程序员老王，我们下期再见。",
  "title": "",
  "author": "",
  "publish_date": "",
  "source": "Bilibili (via SnapAny + Paraformer)",
  "language": "zh-CN",
  "word_count": 2171,
  "extraction_method": "snapany_paraformer",
  "extraction_timestamp": "2025-11-13T12:02:53.396830",
  "batch_id": "20251113_034911",
  "link_id": "bili_req20",
  "error": null,
  "summary": {
    "transcript_summary": {
      "key_facts": [
        "AI agent 是在用户 AI 模型与功能函数之间传递指令的小程序",
        "AI 模型无法直接读取本地硬盘，需通过函数调用实现文件操作",
        "read_file、list_files、rename_file 是用于管理文件的三个预定义函数",
        "函数名和参数名应清晰明确，返回值和参数类型需有明确标注",
        "函数文档字符串（docstring）可帮助 AI 理解复杂函数的行为",
        "AI agent 通过 system prompt 定义角色，如“经验丰富的程序员”",
        "agent 使用 Python 的 dotenv 文件加载 API 密钥以提高安全性",
        "模型实例通过 ginine model 创建，其 API 密钥建议存于环境变量或 .env 文件",
        "agent 通过两个参数注册工具函数：模型实例和 system prompt",
        "run_think 函数接收用户输入并由 agent 自动调用相应函数执行任务",
        "每次调用 run_think 默认不保留上下文，对话状态独立",
        "可通过 message_history 参数传入历史记录以实现上下文记忆",
        "AI agent 可根据上下文决定是否重复读取已访问文件",
        "文件重命名操作基于内容分析结果自动执行，无需重复读取",
        "test 目录中的文件名已按内容正确更新为带扩展名的格式"
      ],
      "key_opinions": [
        "将 AI 视为程序员，提供清晰的 API 和文档是关键",
        "直接在代码中写 API 密钥不安全，应使用环境变量或 .env 文件",
        "若函数复杂，仅靠名称不足以说明功能，需补充 docstring",
        "agent 不自动记住上下文，需手动维护聊天历史记录",
        "当前架构逻辑简单但机制有趣，值得深入理解"
      ],
      "key_datapoints": [
        "视频讲解时长约为十分钟，涵盖 agent、prompt、function calling、MCP 关系",
        "使用 Google 的 Gemini 模型作为 AI 后端，支持多种模型接口",
        "函数包括 read_file、list_files、rename_file 三种基本操作",
        "通过 .env 文件加载 API 密钥，避免硬编码暴露风险",
        "每次调用 run_think 后可获取完整对话记录用于历史传递",
        "测试中成功识别 A、B、C、D 四个文件的编程语言",
        "文件重命名后，所有文件名均正确添加了扩展名",
        "系统通过 list_files 先列出全部文件，再逐个读取内容",
        "一次请求中，AI 调用了多个函数完成多步骤任务",
        "主程序通过标准输入接收用户指令，输出最终结果"
      ],
      "topic_areas": [
        "AI agent 架构",
        "函数注册与调用",
        "上下文记忆机制",
        "API 安全实践",
        "文件管理功能",
        "prompt 与角色设定",
        "文档字符串作用",
        "dotenv 配置管理",
        "多步任务执行流程",
        "代码实操演示"
      ],
      "word_count": 31,
      "total_markers": 30
    },
    "comments_summary": {},
    "created_at": "2025-11-13T12:06:41.616554",
    "model_used": "qwen-flash"
  }
}