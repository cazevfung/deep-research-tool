{
  "success": true,
  "bv_id": "BV1TSg7zuEqR",
  "url": "https://www.bilibili.com/video/BV1TSg7zuEqR/",
  "content": "今天我们来聊聊agent，它也叫AI agent，这是一个随着大模型热潮而兴起的重要概念，虽然agent这个词现在被频繁的提起，但它究竟是什么，是如何运作的，很多人其实并不清楚。所以在这个视频里面，我会带你彻底搞明白这两个问题。在正式开始前，我需要先提醒一下，视频前半部分的一些内容和我之前发过的mp终极指南番外篇有所重合。如果你已经看过那一篇了，那这个视频就建议从react代码的实现部分开始观看。大家都知道现在的大模型，比如gp 4o deep sick之类的，他们回答问题很厉害，逻辑也很强，但平时我们用他们的时候呢，会发现一个限制，他们无法感知或者是改变外界环境。这句话是什么意思呢，我举一个例子来给你说明一下，比如你想让gb 4o帮你写一个贪吃蛇游戏，他确实可以给你代码，但是写完之后，像把代码写入到文件这种事情还是得你自己动手。也就是说，大模型无法改变外界环境，而且有没有一种可能，你其实已经有一些贪吃蛇的代码了，你只是想让模型帮你基于这些代码来改写，增加一些功能，在这种情况下，你就必须把你已有的代码复制给GBD4O才行。我们不主动告诉GBD4O的话，他是无法自己查到这些代码的，换句话说，这就是大模型无法感知外界环境的体现，所以综合来看，大模型是无法感知或者是改变外部环境的。那有没有办法解决掉这个问题呢？其实是有的，我们给他接上对应的工具就可以了。比如说是读写文件内容的工具，查看文件列表的工具，运行终端命令的工具。工具呢就像是大模型的感官和四肢，有了它大模型就可以自己查询已有文件，自己写入代码，自己运行程序，整个过程不需要我们插手，完全自动化，像这样把一个大模型和一堆工具组装起来，变成一个能感知和改变外界环境的智能程序，我们就称它为agent。通常agent用一个机器人来表示，这与大模型的大脑图标形成了鲜明的对比，毕竟agent有了感官和四肢嘛，能自己独立做事了，就像一个机器人一样。Agent呢有很多类型，前面举的是编程类的agent，它可以用来开发程序。除此之外还有一些agent可以做P T，有一些agent可以深度搜索等等等等。总的来说agent的类型有很多，擅长的领域呢也各不相同。下面我们来举几个具体点的例子。第一个例子便是大名鼎鼎的cursor。相信即使你没有使用过它，也多多少少听说过它的存在。Cursor是一个用于编程的agent，我们只需要给他提交任务，它便会调用大模型和各种工具来帮我们写代码，直至完成任务。整个过程中，你顶多点个确定按钮，别的基本上什么也不用动。再举一个例子，前一阵子比较火的minus它也是一个agent。在这个例子中用户希望minus帮他比较几个手机的性能、照相等能力。为了解决用户的问题，minus会生成执行计划，搜索并浏览相关网页，最后把报告整理成一个页面展示给用户看，整个过程基本上也不需要用户插手，minus利用大模型和一些工具就可以解决掉用户的问题。好，相信到这里呢你对agent就有一个大致的了解了。下面呢我们就来讲讲agent的运行模式。Agent的运行有很多种模式，其中最有名的一种是react。React本身是一个缩写，它的全称是reasoning and acting，也就是思考与行动。React可能是目前使用最为广泛的agent运行模式。如果你要学习agent的实现原理，那你就绝对绕不开react，这个模式最初由2022年10月份的一篇论文提出，虽然距离现在已经有接近三年的时间了，但是他所提出的agent的运行模式仍然有着非常广泛的使用。说他是目前使用最为广泛的A城的运行模式也不为过。在这种模式下，用户先提交任务，然后agent先做思考，英文是thought，他思考后会决定是否调用工具，如果是的话，他便会去调用合适的工具，比如读取文件，写入文件内容之类的。React称这一步是行动，英文是action。在行动后，agent会去查看工具的执行结果，比如所读取的文件内容，写入是否成功等等。React称这一步是观察，也就是观察工具执行结果。英文是observation，在观察之后，react会继续思考，他会再次判断是否需要调用工具，如果还是需要的话，他就会继续重复之前所说的行动观察思考的流程，直到某个时刻他认为不需要再调用工具了，可以直接给出结论了。此时他就输出了最终答案，英文是final answer，整个流程到此结束。所以从这个流程图里面也可以看出，react流程的核心步骤是thought、action、observation和final answer。记住这几个词，我们后面呢会用到。了解了react模式的流程之后，下一个问题就是这种react模式是如何实现的。为什么模型拿到用户问题之后会先思考再行动？他为什么不直接行动？是因为模型就这么训练的吗？不是的这跟模型的训练过程关系不大。大部分奥秘呢其实都集中在系统提示词上。系统提示词是跟用户问题一起送给模型的提示词。他规定了模型的角色运行时要遵守的规则，以及各种环境的信息等等。比如我们在系统提示词里面写，你的回答必须包含两个excl标签，一个叫做question，用于存放用户的问题，一个叫做answer，用于存放你的回答，你把这个系统提示词和用户问题一起发给大模型。在这种情况下，大模型便会遵循这种规范来输出答案。上面举的是一个简单的例子，如果你想要模型按照react模式返回答案的话呢，那你的系统提示词就会更加复杂一些。我这里呢就有一个具体点的例子，这个系统提示词大致有五个部分，分别是职责描述事例、可用工具、注意事项和环境信息。我们来仔细读一下。首先看职责描述部分，你需要解决一个任务，为此你需要将任务分解为多个步骤。对于每个步骤首先使用thought思考要做什么，然后使用action调用一个工具，工具的执行结果会通过observation返回给你持续这个思考和行动的过程，直到你有足够多的信息来提供final answer。这一段话呢其实就是在描述我们刚才的那个react执行流程图。我们希望大模型按照react这个标准来运作。后面呢则是专门说明了每个标签的功能。紧接着我举了几个例子，比如说第一个用户的问题是埃菲尔铁塔有多高？模型呢就先用thought标签做了一些思考，然后再使用action调用了get he工具常用的参数呢是埃菲尔铁塔工具的返回结果通过observation返回给了模型。模型接到结果之后呢，他再做了一些思考，然后就给出了最终的答案，这个就是一个非常典型的react流程。后面的例子二呢其实也是类似，只不过是他调用工具调了两遍啊，这个我们就不细说了。再往后我这里列举了一些可用的工具，分别用于读取文件内容，写入文件内容和运行终端命令，都是非常常用的功能，然后呢我们列举了一些注意事项就是在这里，而且告诉了大模型相关的一些环境信息，比如说是当前的操作系统目录和目录下的文件列表等等。下面我们就来演示一下如何使用这个系统提示词。我们用deep stick来举例，我们先把我们的系统提示词复制一下，然后粘贴进来作为用户输入的一部分。之后再在后面加上具体要完成的任务，写一个贪吃蛇游戏，使用htm l css和J S实现代码分别放在不同的文件中。有一点需要提一下，按照规范的做法，系统提示词和用户任务应该分开传给模型。但deep并没有提供单独提交系统提示词的地方，所以呢我们就把系统提示词和用户任务合在一起，当成一条消息提交给他。这样的处理方式在大多数的情况下也是没有问题的，模型依然能够按照预期运行。好，让我们提交任务，可以看到deep ck开始运行了让我们稍等一下，让他运行完毕。可以看出他按照我们的要求先在source标签里面思考了一下，然后他使用action标签请求调用right above工具来写入index dtl文件，这后面就是具体的文件内容了，大家注意我的措辞啊，大模型请求调用工具这里体现的是请求两个字，大模型本身是不能调用工具的，调用工具的是agent的工具，调用组件这里大模型只能是请求。现在如果运行的是一个真的agent的话，它便会去调用工具背后的right form函数写入H tm l文件内容。不过我们现在的模拟嘛，我们就假设调用已经完成了，并且假设工具的返回结果是写入成功，所以我们回复observation写入成功。拿到这个结果后，deep stick又开始运行了，这次他还是先用thought标签思考了一下，然后再使用action标签请求写入css文件的内容。我们照例回复写入成功，deep sick又开始返回了让我们稍等一下。可以看出deep Seeck还是先用thought思考，再用action请求写入gs s文件的内容，我们还是回复写入成功，然后deep sick的返回就有了些变化，因为三个必要的文件都已经写入完成了，不需要再调用工具了，因此deep Seeck的thought之后返回了一个final answer，整个回答就彻底结束了。你看，这就是react模式真正运行时的节奏，每一步都按照系统提示词的要求来，thought action observation, thought action observation, 一直到任务完成，此时会输出thoughts和final answer。系统提示词就相当于给模型安排了一个迷你剧本，他会严格按照这个剧本一步一步的走完。前面我们用deep演示了一个agent的运行流程，可以看到整个流程的关键在于系统提示词，它决定了模型该如何一步步运行。其实在这个系统提示词的基础上，再加上一些配套的代码，我们就可以搭建出一个真正可用的react agent。实际上我已经把这个agent写好了，就放在我的get help仓库里，有需要的同学可以自行获取。接下来我先演示一下这个agent的使用过程，随后再带大家一起看一遍它的代码。我已经进入到这个agent所处的项目目录了，我们先执行一下命令，看一下这个项目目录里面都有什么文件。这里文件很多啊，但实际上你只有两个文件需要留意一下。第一个是agent的pi文件，这个文件里面就写了我们的agent的代码，我们等会儿要运行的就是这个文件。另外一个是snake文件夹，它里面什么也没有。我用tree命令给你证实下，可以看出确实没有任何文件。等会儿我就会让agent把代码写入到这个文件夹里面。好，介绍完毕。下面我们来执行一下这个agent，让你看看他是如何运作的。首先我们启动一下这个agent，我们用的命令是uv run agpi snake。前面的uv run agent pe就是用来启动agent的pi文件的，后面的snake是agent pi这个脚本的第一个参数，意思是告诉agent的p他要操作的项目目录是snake代码就写在那里面，agent点p首先向我们询问需要完成的任务，我们的任务就是写一个贪吃蛇游戏。使用htm l css和J S实现代码分别放在不同的文件中回agent p已经开始运行了，它现在正在请求大模型，我这里采用了同步返回的机制，所以需要等模型把所有内容都生成完毕之后才能看到结果。其实也可以用流式返回的模型，返回几个字就能看到几个字，这样可能效果更好一点。不过代码的复杂度会增加，所以综合权衡之后我就没有使用流式返回。好看到第一轮的结果了。我们的结果一共是包含三个部分，thoughts、action、observation, 跟我们之前在deep sick那里看到的一模一样。这里的action是请求调用right for工具写入index点H tl文件后面的observation显示的就是具体的调用结果了。写入成功。注意啊，这个写入成功可不是模拟的这是真的执行了right for工具，工具也真的返回了写入成功这几个字。好，这个呢是第一部分。我们把滚动条往下拉一拉，看一下剩下的部分是个什么样子的。后面的流程呢也基本类似，可以看到在。",
  "title": "",
  "author": "",
  "publish_date": "",
  "source": "Bilibili (via SnapAny + Paraformer)",
  "language": "zh-CN",
  "word_count": 4899,
  "extraction_method": "snapany_paraformer",
  "extraction_timestamp": "2025-11-13T11:59:57.044864",
  "batch_id": "20251113_034911",
  "link_id": "bili_req15",
  "error": null,
  "summary": {
    "transcript_summary": {
      "key_facts": [
        "Agent 是将大模型与工具结合以感知和改变外部环境的智能程序",
        "大模型本身无法感知或改变外界环境，需通过工具扩展能力",
        "工具如文件读写、终端命令执行等，相当于大模型的感官和四肢",
        "React 模式是目前最广泛使用的 agent 运行模式，全称为 reasoning and acting",
        "React 模式包含 thought、action、observation、final answer 四个核心步骤",
        "系统提示词定义了 agent 的行为规范，决定其是否遵循 React 流程",
        "系统提示词通常包括职责描述、示例、可用工具、注意事项和环境信息",
        "DeepSeek 可用于演示 React 模式，但需将系统提示词与任务合并发送",
        "真实 agent 中，大模型仅请求调用工具，实际执行由工具组件完成",
        "agent 的代码可基于系统提示词和配套逻辑实现，已开源在 get help 仓库",
        "agent 在运行时会按顺序输出 thought、action、observation，直至 final answer",
        "项目中使用 uv run agent.py snake 命令启动 agent 并指定操作目录",
        "snake 文件夹初始为空，agent 将在此目录下生成 HTML/CSS/JS 文件",
        "agent 使用同步返回机制，等待模型完整生成内容后才显示结果",
        "实际调用工具时，工具返回写入成功表示操作已真实执行"
      ],
      "key_opinions": [
        "React 模式是目前使用最广泛的 agent 运行模式，具有高度实用性",
        "系统提示词的设计对 agent 行为起决定性作用，相当于迷你剧本",
        "虽然 DeepSeek 不支持单独传系统提示词，但合并输入仍能正常工作",
        "流式返回虽体验更好，但增加代码复杂度，综合权衡后未采用",
        "Agent 的自动化程度高，用户几乎无需干预即可完成复杂任务"
      ],
      "key_datapoints": [
        "React 模式由 2022 年 10 月论文首次提出，至今已有近三年历史",
        "系统提示词包含五个部分：职责描述、事例、可用工具、注意事项、环境信息",
        "演示中使用 DeepSeek 模型进行 agent 流程测试，任务为编写贪吃蛇游戏",
        "任务要求使用 HTML、CSS、JS 实现，代码分别存于不同文件中",
        "项目目录中存在两个关键文件：agent.py 和 snake 文件夹",
        "agent 启动命令为 `uv run agent.py snake`，参数指定目标目录",
        "工具调用返回结果包含“写入成功”字样，表示操作已完成",
        "整个流程共经历多次 thought-action-observation 循环，最终输出 final answer",
        "系统提示词中明确要求使用 <thought>、<action>、<observation>、<final_answer> 标签",
        "演示中使用 tree 命令确认 snake 目录初始无任何文件"
      ],
      "topic_areas": [
        "Agent 定义与功能",
        "React 运行模式",
        "系统提示词设计",
        "工具集成机制",
        "代码实现演示",
        "大模型局限性",
        "自动化任务处理",
        "文件操作流程",
        "开发环境配置",
        "AI 工具链应用"
      ],
      "word_count": 55,
      "total_markers": 30
    },
    "comments_summary": {},
    "created_at": "2025-11-13T12:06:00.366310",
    "model_used": "qwen-flash"
  }
}