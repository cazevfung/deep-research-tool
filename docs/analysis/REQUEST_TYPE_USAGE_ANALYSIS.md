# 请求类型使用分析报告

## 数据概览

基于 `session_20251113_135641.json` 的分析：

- **总步骤数**：15个 context request 步骤
- **发出请求的步骤**：2个（13.3%）
- **未发出请求的步骤**：13个（86.7%）
- **总请求数**：4个

## 请求类型分布

| 请求类型 | 使用次数 | 占比 |
|---------|---------|------|
| `semantic` | 2次 | 50% |
| `by_marker` | 2次 | 50% |
| `full_content_item` | 0次 | 0% |
| `by_topic` | 0次 | 0% |

## 详细案例分析

### Step 12 的请求

**请求1：semantic**
```json
{
  "request_type": "semantic",
  "query": "霍兰德职业兴趣测试（Holland Code）或MBTI性格类型指标如何用于大学生职业决策支持",
  "source_link_ids": ["yt_req16", "yt_req17", "bili_req9"],
  "reason": "尽管已获取部分上下文，但仍缺乏关于霍兰德与MBTI测评工具在AI对话流中具体整合机制的直接证据"
}
```

**请求2：by_marker**
```json
{
  "request_type": "by_marker",
  "marker_text": "EQI and Science assessments generate reports on potential career paths",
  "source_link_id": "yt_req18",
  "context_window": 3000,
  "reason": "需确认外部评估工具输出的数据结构与格式"
}
```

### Step 19 的请求

**请求1：semantic**
```json
{
  "request_type": "semantic",
  "query": "请提供职业教练Brian Epstein和Jennifer Kohler与客户之间关于处理职业迷茫和身份认同危机的具体对话范例，特别是他们如何使用共情、提问和叙事重构技术来缓解焦虑",
  "source_link_ids": ["yt_req16", "yt_req18"],
  "reason": "当前检索到的完整内容仍为宏观介绍，缺乏具体的、逐字逐句的咨询对话记录"
}
```

**请求2：by_marker**
```json
{
  "request_type": "by_marker",
  "marker_text": "The fourth industrial revolution raises concerns about job stability due to artificial intelligence",
  "source_link_id": "yt_req17",
  "context_window": 5000,
  "reason": "需获取Sharon Belden Castonguay演讲中关于如何将对AI取代工作的普遍焦虑转化为个人能动性的论述"
}
```

## 使用模式分析

### ✅ 为什么使用 `semantic`？

**适用场景**：
1. **概念性查询**：需要查找特定主题或概念的相关内容，但不知道确切位置
   - 例如："霍兰德职业兴趣测试如何用于大学生职业决策支持"
   - 这是一个开放性的概念查询，需要语义匹配相关内容

2. **跨文档检索**：需要在多个源中查找相关内容
   - 例如：在 `yt_req16`, `yt_req17`, `bili_req9` 中查找MBTI相关内容

3. **具体细节查询**：需要查找特定类型的详细内容
   - 例如："职业教练与客户之间的具体对话范例"
   - 需要语义匹配对话类内容，而不是简单的关键词匹配

**优势**：
- 灵活性强，可以找到语义相关但关键词不完全匹配的内容
- 支持自然语言查询，更符合AI的思考方式
- 可以跨多个源进行检索

### ✅ 为什么使用 `by_marker`？

**适用场景**：
1. **已知标记文本**：已经从 `marker_overview` 中看到了特定标记，需要获取该标记周围的上下文
   - 例如：已知 "EQI and Science assessments generate reports on potential career paths" 这个标记
   - 需要看这个标记前后3000字的上下文

2. **精确上下文需求**：需要特定位置的详细上下文，而不是整个文档
   - 例如：需要某个特定论述的完整上下文，而不是整个视频的转录

**优势**：
- 精确度高，直接定位到已知的相关内容
- 可以控制上下文窗口大小，避免信息过载
- 效率高，不需要全文检索

### ❌ 为什么没有使用 `full_content_item`？

**可能原因**：

1. **已有概览信息**：AI已经通过 `marker_overview` 看到了内容的关键标记，可能认为：
   - 不需要完整内容，只需要特定部分
   - 完整内容可能包含大量无关信息，增加处理成本

2. **效率考虑**：
   - 完整内容可能很长，增加token消耗
   - 如果只需要特定部分，`by_marker` 更高效

3. **提示词影响**：
   - 示例中虽然展示了 `full_content_item`，但没有明确说明何时应该使用
   - AI可能倾向于使用更精确的请求类型

**建议使用场景**（应该在提示词中明确）：
- 当需要分析整个文档的结构、逻辑流程时
- 当需要查找的内容可能分散在文档各处时
- 当标记概览显示文档整体都相关时

### ❌ 为什么没有使用 `by_topic`？

**可能原因**：

1. **功能重叠**：`by_topic` 和 `semantic` 在功能上可能有重叠
   - `semantic` 已经可以通过自然语言查询实现主题检索
   - AI可能认为 `semantic` 更灵活

2. **提示词不清晰**：
   - `context_request.md` 中只列出了 `by_topic`，但没有说明其与 `semantic` 的区别
   - 没有示例展示何时应该使用 `by_topic` 而不是 `semantic`

3. **Schema 差异**：
   - `by_topic` 需要 `topic` 和 `source_link_ids` 参数
   - `semantic` 需要 `query` 和 `source_link_ids` 参数
   - 两者在参数上相似，AI可能选择了更熟悉的 `semantic`

**建议使用场景**（应该在提示词中明确）：
- 当需要按预定义的主题分类检索时
- 当需要限制检索范围到特定主题时
- 当主题是结构化的、可枚举的概念时

## 问题诊断

### 1. 提示词不够明确

**当前问题**：
- `context_request.md` 只列出了4种请求类型，但没有说明：
  - 每种类型的适用场景
  - 何时应该选择哪种类型
  - 不同类型之间的区别

**改进建议**：
```markdown
**请求格式**：
- 使用 `request_type: "full_content_item"` 请求完整内容
  - **适用场景**：需要分析整个文档的结构、逻辑流程，或内容可能分散在文档各处
  - **示例**：需要完整视频转录以分析整体论证结构
  
- 使用 `request_type: "by_marker"` 请求特定标记的上下文
  - **适用场景**：已从标记概览中看到相关标记，需要获取该标记周围的详细上下文
  - **示例**：已知 "FACT: X" 标记，需要看前后2000字的上下文
  
- 使用 `request_type: "semantic"` 请求语义检索
  - **适用场景**：需要查找特定主题或概念的相关内容，但不知道确切位置或标记文本
  - **示例**：需要查找"如何应对职业焦虑"的相关内容，但不知道具体在哪个位置
  
- 使用 `request_type: "by_topic"` 请求主题相关内容
  - **适用场景**：需要按预定义的主题分类检索，或需要限制检索范围到特定主题
  - **示例**：需要查找所有关于"职业规划"主题的内容
```

### 2. 示例不够全面

**当前问题**：
- 示例只展示了 `full_content_item` 和 `by_marker`
- 没有展示 `semantic` 和 `by_topic` 的示例

**改进建议**：
在示例中添加所有4种类型的示例，让AI看到每种类型的具体用法。

### 3. 决策逻辑不清晰

**当前问题**：
- AI需要自己判断使用哪种类型，但缺乏明确的决策标准

**改进建议**：
添加决策流程图或决策树，帮助AI选择最合适的请求类型。

## 改进建议

### 短期改进（立即实施）

1. **增强提示词**：
   - 为每种请求类型添加明确的适用场景说明
   - 添加所有类型的示例
   - 添加决策指导

2. **添加对比说明**：
   - 明确说明 `semantic` vs `by_topic` 的区别
   - 明确说明 `full_content_item` vs `by_marker` 的区别

### 长期改进（架构优化）

1. **请求类型优化**：
   - 考虑是否需要 `by_topic`，或者是否可以合并到 `semantic` 中
   - 考虑是否需要添加更多请求类型（如 `by_keyword`, `by_time_range` 等）

2. **智能推荐**：
   - 根据可用上下文（如 `marker_overview`）自动推荐最合适的请求类型
   - 提供请求类型选择的建议

3. **使用统计**：
   - 跟踪不同请求类型的使用频率和效果
   - 根据统计数据优化提示词和请求类型设计

## 结论

当前AI主要使用 `semantic` 和 `by_marker` 两种请求类型，这反映了：

1. **AI的决策逻辑**：
   - 倾向于使用灵活且精确的请求类型
   - 避免请求完整内容（可能因为效率考虑）
   - 没有使用 `by_topic`（可能因为功能重叠或提示词不清晰）

2. **提示词的问题**：
   - 缺乏明确的适用场景说明
   - 示例不够全面
   - 决策逻辑不清晰

3. **改进方向**：
   - 增强提示词的明确性和完整性
   - 提供更多示例和决策指导
   - 考虑优化请求类型的设计

